<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V4.1.2.5//EN"
    "http://www.oasis-open.org/docbook/xml/simple/4.1.2.5/sdocbook.dtd">

<article class="whitepaper">
    <title>Module Implementation</title>
    
    <articleinfo>
        <author><othername>akarasulu</othername></author>
        <editor><othername>$Author: bearcej $</othername></editor>
        <revhistory>
            <revision>
                <revnumber>$Revision: 1.6 $</revnumber>
                <date>$Date: 2003/05/03 01:43:08 $</date>
                <revdescription>
                    <para>
$Log: backend-module.xml,v $
Revision 1.6  2003/05/03 01:43:08  bearcej
Add maven file to help generate server site.
Modify graphic links again.
Remove tabs from doc files and fix linefeeds.

Revision 1.5  2003/05/03 01:21:32  bearcej
Remove tabs from doc files and fix linefeeds.

Revision 1.4  2003/04/21 21:11:50  bearcej

* Fix broken links in documentation.

Revision 1.3  2003/04/08 02:29:55  bearcej
* Clean up project.properties
* Fix logos in project.xml
* Fix links to image files in docs

Revision 1.2  2003/03/23 13:24:46  akarasulu
Added these files from the ALPHA-0_7 branch.

Revision 1.1.2.5  2003/03/15 17:35:24  bearcej
Fix href to BackendInterface.gif

Revision 1.1.2.4  2003/03/15 17:07:26  bearcej
Fix figure tags to conform to simple docbook (note: maven will not handle
correctly without a maven patch)
Modified Files:
 Tag: ALPHA-0_7
    backend-module.xml

Revision 1.1.2.3  2003/03/12 02:11:56  akarasulu
Checking partial backend module docs.

Revision 1.1.2.2  2003/03/11 01:26:41  akarasulu
Started up BackendModule documentation - more to come soon.

Revision 1.1.2.1  2003/03/10 23:24:19  akarasulu
Moved design documentation from docs/design to src/docbook/design.

Revision 1.1.2.2  2003/03/10 23:12:06  akarasulu
Moved these images to src/xdocs/design

Revision 1.1.2.1  2003/03/03 04:49:25  akarasulu
Added as placeholders for now.

                    </para>
                </revdescription>
            </revision>
        </revhistory>
    </articleinfo>

    <abstract>
        <para>
            The BackendModule is an abstract base class which implements the
            AtomicBackend service interface.  The abstract module provides a 
            starting point for backend module developers.  Backend modules are 
            the Directory Information Bases (DIB) which store entries served 
            by the directory.  Several backends of various types may coexist 
            within the same directory under different naming contexts.  The goal
            of this document is to describe the server to backend contract 
            specified by interfaces within the org.apache.eve.backend package.
            Special emphesis will be placed on the the AtomicBackend service 
            interface, as well as other helper interfaces and classes.  
        </para>
    </abstract>
    
    <section>
        <title>Document TODOs:</title>
        <itemizedlist>
            <listitem><para>
                Add diagrams.
            </para></listitem>
        </itemizedlist>
    </section>
    
    <section>
        <title>Architecture</title>
        
        <para>
            Backends relate one to one with naming contexts exposed by the
            server.  Backends are specialized databases customized for the 
            storage and retieval of entries participating within a DIB's 
            namespace.  The LDAP access model and naming model are tightly 
            intertwined.  The interfaces defining a backend module reflect
            the tight coupling between these models.  The operations against
            backends fit into one of three categories: configuration parameter 
            methods, structural DIT management operations and nCRUD entry 
            life-cycle operations.
        </para>
        
        <para>
            Backends require interfaces to Create, Read, Update and Delete 
            (CRUD) entries.  These operations form the basis the CRUD life-cycle
            model for in-memory objects repeatedly retrived from and stored
            back to disk.  For the purpose of this discussion, we refer to the
            copy held on disk as the disk shadow copy.  It shadows the in-memory
            image rather than mirroring it, since at any instant in time the
            in-memory image may not be the same as the shadowed image on disk.
            Under such circumstances the in-memory image is considered dirty.
            The process of applying the computations used to synchronize 
            in-memory images is called store optimization.  Store optimization
            reverts dirty entires to clean entries.  Every backing store 
            confronts the task of store optimization at some point.  A backend 
            module is no exception and the exact means used to acheive 
            synchronization is highly specific to the backing store 
            implementation.  Regardless of the backend implementation, the 
            architecture strives to abstract away storage mechanisms to present
            a common entry life-cycle facade.  The use of the CRUD model 
            achives this goal by breaking down the life-cycle into small atomic
            operations easily implemented by encapsulating specific data 
            storage mechanisms.
        </para>
        
        <para>
            Under CRUD, the addition of an entry to a backend requires an 
            initial set of attributes, followed by a create operation.  The
            create operation arguments provide the initial attribute set 
            required to prevent a schema violation based on the entry's
            objectclasses.  The identifiers, values and number of attributes 
            composing the initial set vary with respect to the entry.  If the 
            language supports variable argument lists, attribute ids and values 
            could be provided directly as create arguments.  Better yet an 
            empty entry object without a respective shadow copy on disk, could
            be instanciated and populated with attributes.  The in-memory
            entry object could then be used as the sole argument to a create 
            operation passing in all required attributes and their values in
            one object.  The latter approach leads to cleaner code and to a 
            slightly altered version of the CRUD model.  Instantiation of the
            in-memory entry shell, without a shadowed disk image, adds the
            less central 'New' operation to CRUD.  The addition of the 'New' 
            operation yeilds the modified CRUD or nCRUD model.  The core Backend
            super interface supports the nCRUD entry life-cycle model by 
            declaring the following methods:
        </para>
        
        <table id="tab1">
            <title>Supported nCRUD Operations</title>
            <tgroup cols="5">
                <thead>
                    <row><entry>Method</entry>
                    <entry>CRUD Op</entry>
                    <entry>Source State</entry>
                    <entry>Target State</entry>
                    <entry>Description</entry></row>
                </thead>
                <tbody>
                    <row>
                        <entry>newEntry(String a_dn):LdapEntry</entry>
                        <entry>New</entry>
                        <entry>NA</entry>
                        <entry>New</entry>
                        <entry>
                            Creates a new invalid LdapEntry object instance
                            only.  Invalid entries are not shadowed in the 
                            backing store, they are merely empty containers.
                        </entry>
                    </row>
                    <row>
                        <entry>create(LdapEntry a_entry):void</entry>
                        <entry>Create</entry>
                        <entry>New</entry>
                        <entry>Clean</entry>
                        <entry>
                            Clean entries are valid LdapEntry object 
                            instances that are consistant with their mirror
                            image in the backing store.
                        </entry>
                    </row>
                    <row>
                        <entry>read(Name a_dn):LdapEntry</entry>
                        <entry>Read</entry>
                        <entry>NA</entry>
                        <entry>Clean</entry>
                        <entry>
                            Instantiates a valid LdapEntry instance to 
                            mirror the copy held within the backing store.
                        </entry>
                    </row>
                    <row>
                        <entry>update(LdapEntry):void</entry>
                        <entry>Update</entry>
                        <entry>Dirty</entry>
                        <entry>Clean</entry>
                        <entry>
                            Updates the shadow copy in the backing store to
                            mirror the in memory LdapEntry image supplied.
                        </entry>
                    </row>
                    <row>
                        <entry>delete(LdapEntry):void</entry>
                        <entry>Delete</entry>
                        <entry>Clean|Dirty</entry>
                        <entry>Deleted</entry>
                        <entry>
                            Deletes the shadowed copy within the backing 
                            store, and invalidates the LdapEntry argument.
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
            
        <para>
            The Backend super interface declares the minimum set of operations
            required to manage a DIB.  These methods include the nCRUD 
            operations tabulated in Table I above.  nCRUD operations model the 
            entry life-cycle causing transitions between entry states depicted 
            in Figure I below.  The states are implied abstract nCRUD states.  
            They are not necessarily modeled explicity within any 
            implementation.
        </para>
        
        <figure id="fig1">
            <title>CRUD Life-cycle States</title>
            <graphic fileref="../images/CRUDLifecycle.gif"/>
        </figure>
        
        <para>
            The Backend interface also declares DIB namespace management 
            operations.  Namespace management operations affect the structure
            of the DIB without adding or removing entries.  Name modifications 
            upon entries occur to reflect namespace alterations.  Entry 
            attributes other than those used for the relative distinguished 
            name (RDN) never change.  Examples of such operations are move()
            and modifyRdn().  Other Backend interface operations like search(), 
            getParent(), hasEntry() and listChildren(), do not fit into either 
            the nCRUD category nor do they fit into the catagory of namespace 
            operations.  They are modified Read operations which enable specific
            lookups and generalized mass Reads as DIB queries.
        </para>
        
        <para>
            The Backend super interface is extended by two sub interfaces:
            UnifiedBackend and AtomicBackend.  Both are Avalon service 
            interfaces.  <ulink url="http://avalon.apache.org/framework/">
            Avalon Framework</ulink> defines the concept of a service as a
            interface fulfilling a role within a system.  The idea leads to
            Service Oriented Programing (SOP), which breaks a system down into 
            a set of services.  By convention Avalon, differentiates service
            interfaces from ordinary interfaces based on the present of a ROLE
            constant.  The ROLE constant is a String set to the fully qualified
            name of the service interface.  An example of a service interface
            is shown below:
        </para>
        
        <programlisting>
            package com.calculator
            
            interface CalculatorService 
            {
                String ROLE = "com.calculator.CalculatorService" ;
                
                int add(int a_arg1, int a_arg2) ;
                int sub(int a_arg1, int a_arg2) ;
                int div(int a_arg1, int a_arg2) ;
                int mlt(int a_arg1, int a_arg2) ;
            }
        </programlisting>
        
        <para>
            The CalculatorService service interface exposes a set of arithmetic
            operations accessible to other services within a system.  Note the
            ROLE constant which is set to the fully qualified name of the 
            interface.   Unlike this example service interface the Backend 
            interface does not have a ROLE constant, hence it is not a service 
            interface.  The Backend interface alone cannot be implemented by a 
            module within the server, instead one of its sub interfaces must be
            implemented.
        </para>
        
        <para>
            The AtomicBackend interface is a service interface according to the
            Avalon definition with a ROLE constant set to the fully qualified
            name of AtomicBackend: org.apache.eve.backend.AtomicBackend.  All 
            backends
            
            <footnote>
                <para>
                    Until now we loosely referred to a naming context's DIB as 
                    a backend and will continue to do so.  For lack of a better 
                    term, all AtomicBackend implementations are simply referred 
                    to as backends in lowercase.  When we specifically refer to 
                    the Backend interface, the 'B' in Backend will be 
                    capitalized and followed by the word 'interface'.
                </para>
            </footnote>
            
            bound to an indivisible naming context implement the 
            AtomicBackend service interface.  Indivisible implies that all 
            entries within the context's namespace are stored within a single 
            DIB: an implementation of AtomicBackend.  The UnifiedBackend in 
            contrast unifies the namespaces of all AtomicBackends under one 
            composite Backend.  The <ulink url="nexus-module.html">NexusModule
            </ulink> documentation discusses the UnifiedBackend service 
            interface and its implementation in more detail.
        </para>
        
        <figure id="fig2">
            <title>Figure II: Backend Interfaces</title>
            <graphic fileref="../images/BackendInterfaces.gif"/>
        </figure>
        
        <para>
            The interface heirarchy differentiates common DIB operations from 
            those that are specific to the UnifiedBackend and an AtomicBackend.
            The Backend super interface contains methods common tto both
            services.  Inspection of <link linkend="fig2">Figure II.</link>
            reviels the differentiating methods between the two service 
            interfaces which consequently defines their specific roles and their
            behavoir.  An AtomicBackend has a suffix, or naming context root 
            specified by a (non-empty string) LDAP distinguished name.  The
            UnifiedBackend does not.  The UnifiedBackend cannot return a suffix
            DN if it is composed of many naming contexts.  Which context root
            would it return?  Furthurmore, it would be redundant to have a
            getSuffix() method on the UnifiedBackend interface since the implied
            suffix for the UnifiedBackend is the root of all roots: the empty 
            string DN.  The AtomicBackend inherits method declarations from the
            BackendConfig super interface through interface polymorphism and 
            UnifiedBackend does not.  The BackendConfig interface defines 
            standard configuration parameters applicable only to backends that 
            directly store entries.  Configuration parameters like isReadOnly() 
            does not make sense for a forwarding UnifiedBackend which delegates
            entry and namespace operations to owning AtomicBackends.  Nothing 
            makes the distinction more apparent than the methods exposed by the 
            UnifiedBackend which register, unregister, list, and return 
            AtomicBackends and the context's they are bound to.
        </para>
            
        <para>
            The Backend interface is the common super interface for all 
            services providing DIB operations like nCRUD operations and 
            namespace operations.  It's methods alone do not constitute a 
            service.  Our intention was to allow for two drastically different
            backend types while making their differences transparent through
            the common Backend super interface.  This way conversations between
            each AtomicBackend and a caller can be routed by way of the 
            UnifiedBackend.
        </para>
            
        <para>
            With the differences clearly outlined between the core backend
            interfaces, let's consider their simularities and some of the
            common helper classes involved.  Close inspection reviels the
            throws of NamingExceptions within virtually every core backend 
            interface.  The throws directly reflect the close relationship
            between the LDAP access model and the LDAP naming model.  These
            two aspects of LDAP are inseperable.  All entries are named, 
            possesing a unique distinguished name as defined by X.500 and 
            LDAP.  Even the call to instantiate a new entry object via newEntry
            requires a distinguished name.  Naming is inherent to LDAP and 
            cannot be abstracted away from an LDAP DIB.  A name is required to
            retrieve, change or store and search for an entry.
        </para>
            
        <para>
            Up until now, most methods declared by the Backend interface have
            been explained, yet some return types from those methods acting as
            helper classes have not.  Namely, mass read operations or searches 
            return a Cursor.  Before looking at how we define a Cursor as part
            of the server to backend contract lets consider the abstract notion
            of a cursor.  The concept obviously arose from a database server's
            need to conserve resources.  A database server may contain far more
            data than can fit into physical memory, and must share whatever 
            memory resources it has across concurrent clients.  Queries have the
            potential to return a massive amount of data to the client.  For
            these reasons databases do not have the option of buffering query 
            results before transmission to the client.  If they do it must be
            at an extremely minimal level, or it must use seconday disk memory
            to do so.  Cursors are designed to return one search candidate at
            a time streaming results back to the client.
            
            require the concept of a cursor.
            The potential of returning the contents of the entire directory 
            tree exists.  All entries cannot possibly be loaded into memory to
            be returned to the client at any one time with anything but trivial
            databases.  Cursors return values one at a time without requiring
            the entire search set to be in memory at any one time.
        </para>
            
        <para>
            BackendModule simply implements some Avalon life-cycle methods out of the box on
            behalf of the developer trying to write a new type of backend.  Our
            architectural focus is not restricted to this class, however it's 
            value add will be discussed within the implementation section of 
            this document.  For architectural and implementation specific 
            details regarding specific backend implementations available for the
            LDAPd server please consult the backend specific documentation.
            Below we list the various backends available, hyperlinked to their
            documentation sets:
        </para>
        
        <itemizedlist>
            <listitem><para>
                <ulink url="/../../../backend-blank.html">JDBM Module
                </ulink> - Default non-relational module using the
                <ulink url="http://jdbm.sourceforge.net">JDBM BTree</ulink>
                implementation.  JDBM is a Java based UNIX DBM implementation.
            </para></listitem>

            <listitem><para>
                <ulink url="/../../../backend-blank.html">Berkeley Module
                </ulink> - Optional module using the
                <ulink url="http://www.sleepycat.com">BerkeleyDB</ulink> 
                non-relational database.  BerkeleyDB is a native C database that
                uses an API to access BTree backed binary data.
            </para></listitem>

            <listitem><para>
                <ulink url="/../../../module-blank.html">JDBC Module
                </ulink> - Optional module using JDBC to store entries within a
                relational database.
            </para></listitem>
        </itemizedlist>

        <section>
            <title>Entry CRUD Methods And DIB Operations</title>
            
            <para>
                The Backend interface specifies entry Create, Read, Update and
                Delete (CRUD) operations and various DIB operations which don't
                quite fit into a strictly CRUD model.  Examples of such
                operations would be move(), search() and listChildren().  The
                Backend interface declares the minimum set of DIB operations
                expected from a backend.  Notice in <link linkend="fig1">Figure 
                I</link> that all Backend interface methods throw 
                NamingExceptions or one of its subtypes.  The CRUD specific 
                operations are listed below in Table I and the corresponding
                lifecycle state transitions are depicted in Figure II below it:
            </para>
            
            <para>
                The CRUD
            </para>
        </section>
    </section>

    <section>
        <title>Implementation</title>
        
        <para>
        </para>
        
        <para>
        </para>
        
        <para>
        </para>
    </section>
    
    <section>
        <title>Future</title>
        
        <para>
        </para>

        <para>
        </para>
    </section>

    <section>
        <title>Faults</title>
        
        <para>
        </para>
        
        <para>
        </para>
        
        <para>
        </para>
    </section>
    
</article>
