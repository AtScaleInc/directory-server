<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V4.1.2.5//EN"
    "http://www.oasis-open.org/docbook/xml/simple/4.1.2.5/sdocbook.dtd">

<article class="whitepaper">
    <title>Module Implementation</title>
    
    <articleinfo>
        <author><othername>akarasulu</othername></author>
        <editor><othername>$Author: bearcej $</othername></editor>
        <revhistory>
            <revision>
                <revnumber>$Revision: 1.3 $</revnumber>
                <date>$Date: 2003/05/03 01:21:32 $</date>
                <revdescription>
                    <para>
$Log: event-module.xml,v $
Revision 1.3  2003/05/03 01:21:32  bearcej
Remove tabs from doc files and fix linefeeds.

Revision 1.2  2003/03/23 13:24:46  akarasulu
Added these files from the ALPHA-0_7 branch.

Revision 1.1.2.1  2003/03/10 23:24:20  akarasulu
Moved design documentation from docs/design to src/docbook/design.

Revision 1.1.2.3  2003/03/09 22:22:35  akarasulu
For all practical purposes the EventModule documentation is considered
done.  It is not really used yet and when it is we can fill in the
relavent sections.

Revision 1.1.2.2  2003/03/09 22:12:48  akarasulu
Moved the event-model-chapter.xml content into the event-module.xml file.

Revision 1.1.2.1  2003/03/03 04:49:25  akarasulu
Added as placeholders for now.

                    </para>
                </revdescription>
            </revision>
        </revhistory>
    </articleinfo>

    <abstract>
        <para>
            This chapter discusses ldapd's server side protocol event model, 
            its use, design and implementation.  It does not cover the SEDA 
            event model that loosely couples stages within the server.  For lack
            of a better term we refer to this system of events, listeners and 
            sources as the protocol event model.
        </para>
    </abstract>
    
    <section>
        <title>Document TODOs:</title>
        <itemizedlist>
            <listitem><para>
                Add diagrams.
            </para></listitem>
        </itemizedlist>
    </section>
    
    <section>
        <title>
            Potential Uses For Pre And Post Protocol Events
        </title>
        
        <para>
            During the course of processing LDAP requests, subsystems will need 
            to transparently inject their services.  An event model provides a 
            decoupled way for these systems to communicate.  Listeners abstract 
            and decouple interfaces on targets while source interfaces used to 
            register listeners decouple the event source.  Events simply carry 
            payloads of information required to respond appropriately.  Several 
            subsystems will leverage the event model to transparently effect 
            server operations without impossing dependence between themselves 
            and other modules within the server.  This section discusses various
            systems that would benefit from an event model.
        </para>
    
        <para>
            Authorization is an excellent candidate for using the event model.  
            When registered for events, the authorization module will recieve 
            events with profile information and other context information 
            describing the operation being performed.  Of course it makes no 
            sence to have the authorization module recieve these events after an
            operation completes.  So it must recieve pre events to actually 
            intervene in the process, thereby preventing unauthorized requests 
            from being serviced.  Event delivery must notify synchronously of 
            the pending event to allow for the authorization module to 
            intervene.
        </para>
        
        <para>
            A trigger subsystem or module would also depend on an event model.  
            Triggers in the RDBMS world are specified using a set of operations 
            with a modifier used to determine when the trigger fires.  Triggers
            this way can fire before or after an operation takes place.  
            Triggers communicate their objections to the rest of the system by 
            raising exceptions when conditions are not met.  Some triggers are 
            required after an operation has completed.  Regardless of the 
            purpose of a trigger, correct trigger operation is dependent on the 
            receipt of events by the trigger subsystem before and after protocol 
            operations occur.
        </para>
        
        <para>
            Master servers with replicas need to recieve entry change 
            notification events.  Master servers contain a master replication 
            module.  This module enqueue's change events onto the replication 
            queues of the replication subsystem.  These events are used to 
            asynchronously communicate the changes that need to take place to 
            keep replica servers synchronized with master server DIB (Direcotry 
            Information Base) changes.
        </para>
    </section>

    <section>
        <title>
            Aspects Of The Protocol Event Model
        </title>
        
        <para>
            When discussing events, we need to qualify their delivery as 
            synchronous or asynchronous.  Different situations may warrent 
            different delivery timing requirements.  Events are triggered by 
            event sources, then delivered to targets that posses event listener 
            handler methods.  The design of a protocol event model requires the 
            clear definition of the events, targets and sources involved.  These
            concerns and their details must be explored for all conceivable use 
            cases for the protocol event model.
        </para>
        
        <para>
            Listeners registered to receive events often need to effect the 
            outcome of an operation based on some condition.  The authorization 
            module is a good example of such a listener.  It must check to see 
            if each protocol operation is allowed to proceed based on the 
            authorization profile of the user and the parameters of the 
            operation.  If for some reason the user is not allowed to perform 
            the operation, the authorization subsystem must stop the operation.  
            To stop the execution of an operation the delivery of the event must
            occur before the operation begins.  The operation must be kept in a 
            suspended state until the authorization module can evaluate whether 
            access is granted or denied.  The situation requires synchronous 
            event delivery.  If the event is delivered synchronously before the 
            operation begins, the operation waites until the event handlers of 
            the listeners complete - meaning until the authorization module 
            evaluates the operation.  With synchronous deliveray a runtime 
            authorization exception can be raised to stop the current executing 
            thread.  The exception tunnels back up the exception stack of the 
            driving processor thread.  The thread driver traps all exceptions 
            reporting the reason for the failure by packaging the contents of 
            the authorization exception into a return message to the client.
        </para>
    
        <para>
            Synchronous event delivery best suites the needs of the 
            authorization module.  The module easily prevents an operation from 
            executing by throwing an exception.  Because the thread executing 
            the operation is the same thread calling the listener handlers, an 
            exception thrown by a handler interupts the operation.  Most use 
            cases for an event model are satisfied by a synchronous delivery 
            mechanism.  Synchronous delivery of events can be handled 
            asynchronously by target modules.  For example replication is best 
            handled asynchronously.  Upon receiving an event that represents the
            alteration of a mastered DIB the master replication module may use 
            another thread to asynchronously push these events onto a 
            replication event queue.  The delivery of the protocol event is 
            synchronous yet how it is handled becomes asynchronous in the 
            implementation replication module.  Synchronous event delivery does 
            enable listeners to alter the outcome of an operation.  This is 
            great if you need to affect the outcome.  This is not so good if you
            do not want to give such power over the outcome to listener 
            handlers.
        </para>
    
        <para>
            The power to effect the outcome or delay the outcome is given to 
            every listener handler invoked by a processing thread.  Conditional 
            traps can however be used to catch exceptions and ignore them, 
            thereby allowing the operation to continue regardless of bad 
            listener code or listener code objecting to the operation.  This 
            would enable a finer degree of control over how much power is handed
            off to the event handlers of registered listeners.  Modifiers that 
            determine the mode of operation for the registered listener would be
            part of a listener specification.  In terms of delaying the outcome,
            there is very little that can be done outside of using processor 
            thread controls similar to those used for search controls.  For 
            example time limits are used to constrain a search request.  Similar 
            constructs can be used to contstrain the maximum amount of time 
            allowed for a thread to spend processing an event.  If the the 
            thread spends too much time in listener event handlers the operation 
            can be abandoned.  Again parameters used to limit the amount of time
            a thread can spend in the listener handlers should be part of a 
            listener specification defined perhaps at listener registration 
            time.  Perhaps the maximum time limit can be specified based on the 
            event type delivered instead of the listener registered.  In this 
            case the delivery specification must be given with every event 
            fired.  There are several ways in which the behavior of synchronous 
            event delivery can be managed but overall synchronous event delivery 
            is the best way to go for our internal protocol event model.
        </para>
    
        <para>
            Events can be fired from anywhere and delivered to any listener in 
            any order.  There really is no difference between a synchronous 
            event delivery method call and any other method call.  Event 
            listeners simply comply with an interface for recieving a handle on
            a constant event delivered to each listener.  These listeners are 
            called one after the other by the same thread in a firing loop.  
            Any module or operation in the server may initiate the firing of an 
            event.  The firing component is logically the source of the event, 
            in that it drove the creation of the event and triggered its 
            delivery to the target listener interface method.  The source may 
            be coming in from anywhere.  Obviously the protocol module can be
            the source, the JNDI provider can also be the source when the JNDI
            interfaces are used to make changes.  The thread used to drive the 
            change obviously comes from the protocol module as a processor 
            thread.  This will undoubtedly change as we begin to enable timer 
            driven triggers in the server which are scheduled to run stored
            procedures as a particular user.  These will be driven by a timer
            thread or a thread from a central pool.
        </para>
        
        <para>
            Any caller to a listener handler method has the potential to be an 
            event source.  How then do we control and manage event sources and 
            event listeners?  We cannot and should not constrain event inducing
            sources because the picture may change with time as parts of the 
            server are improved.  Sources may change with server module 
            configurations and so should be left undefined.  We should however
            constrain listeners to implement specified interfaces.  New 
            listeners developed can easily implement these interfaces which 
            specify the event types listened for.
        </para>
        
        <para>
            As discussed listeners will need to register themselves with ideally 
            the event source that generates and delivers the event.  This 
            however need not be the case.  With many event models the source 
            requests delivery of events to listeners using a third party which 
            is a central fixture.  Sure listeners are registered at the source
            for events but this need not be the case either.  A central 
            registry can be used to act as a hub for all events generated in 
            the server.  The registry provides interfaces for listeners to 
            register for events.  It can also provide interfaces for firing 
            various events on behalf of the event source.  Under such a
            configuration we would centralize the machinery for the lookup of 
            listeners and the delivery of events based on the event source.  
            All the timing based requirements of event delivery and the traps 
            used to prevent listener interference can be implemented there in
            a central event manager.  Note once again this is separate from the 
            asynchonous events used across server stages.
        </para>
        
        <para>
            Events are modeled to represent protocol operations.  LDAP abandon, 
            add, bind, compare, delete, modify, modify DN, search and unbind
            operations are represented using their own respective event types 
            that derive from one common abstract ProtocolEvent ancestor.  The 
            ProtocolEvent is the abstract based where common functionality or 
            data can be added to the set of events in the model.
        </para>
            
        <para>
            Protocol operations may not directly be driving the firing of 
            events in all cases.   Scheduled maintainence operations triggered
            by a timer may fire events as a consequence of executing the stored
            procedures they invoke.  These stored procedures induce changes
            through the internal server side JNDI provider. No LDAP operation
            recieved from a client as a PDU (Protocol Data Unit) is associated 
            with the events fired by the executing stored procedure.  These 
            phantom events are flagged as such via a boolean property.  This
            property determines whether or not a physical PDU was delivered 
            for the event.  Client operations against the server may raise 
            triggers that fire stored procedures which operate on a DIT within
            the server.  These indirect trigger driven changes will fire
            events that are not associated with a physical PDU and hence will
            have the respective flag set to false.  These events are part of 
            the event cascade centrally rooted at the original event that 
            started the cascade.  We need to differentiate between the root 
            of an event cascade and all other descendent events that may fire
            as a result of the original root event.  Protocol events are 
            designed to keep a handle on a root event.  This way the event 
            cascade tree can be represented using parent child associations.  
            The parent event this way is represented as having triggered a
            child in a cascade of event firings.  The root event of the cascade 
            refers back to itself as the cascade root and also offers an 
            interface to check if it is the root of the cascade this way.  In
            both of these cases (scheduled firing and indirect cascade driven 
            firing) no protocol activity exists yet protocol events will be 
            fired as if a comparable protocol operation were inducing the event.
            The event model captures all the information needed by a listener 
            to differentiate how and why the event was fired.  By determining
            if the event is or is not the root of a cascade and if it is
            directly associated with a physical PDU listeners can take the
            appropriate action after interpreting the context of the event.
        </para>
        
        <para>
            Often one event may trigger another event to be fired.  At times 
            this will naturally result in an event cascade which may be a 
            desirable side effect.  These cascades may result in unbounded 
            cyclic firings within the server if listener event handlers are not
            carefully designed.  The server must detect these dangerous
            conditions and halt the firing of subsequent events.  Luckily since
            synchronous delivery is used we can track the tree of events 
            representing the event cascade by associating the structure with
            the driving thread.  Using this tree carried with the thread of
            execution we can determine if a cyclic firing is occuring and 
            terminate the cascade before a StackOverflowError results.  A 
            central event manager is perfect for placing such code to detect 
            unbounded event cascades and managing a weak thread context hash 
            for the event cascade tree structure.
        </para>
    </section>
    
    <section>
        <title>Implementation</title>
        
        <para>
            Add implementation details here.
        </para>
    </section>
    
    <section>
        <title>Future</title>
        
        <para>
            Add future enhancements here.
        </para>
    </section>

    <section>
        <title>Faults</title>
        
        <para>
            Add faults here.
        </para>
    </section>
    
</article>
