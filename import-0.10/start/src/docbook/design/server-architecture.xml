<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V4.1.2.5//EN"
    "http://www.oasis-open.org/docbook/xml/simple/4.1.2.5/sdocbook.dtd">

<article class="whitepaper">
    <title>Server Architecture</title>
    
    <articleinfo>
        <author><othername>akarasulu</othername></author>
        <editor><othername>$Author: bearcej $</othername></editor>
        <revhistory>
            <revision>
                <revnumber>$Revision: 1.4 $</revnumber>
                <date>$Date: 2003/05/03 01:21:32 $</date>
                <revdescription>
                    <para>
$Log: server-architecture.xml,v $
Revision 1.4  2003/05/03 01:21:32  bearcej
Remove tabs from doc files and fix linefeeds.

Revision 1.3  2003/04/21 21:11:50  bearcej

* Fix broken links in documentation.

Revision 1.2  2003/03/23 13:24:46  akarasulu
Added these files from the ALPHA-0_7 branch.

Revision 1.1.2.3  2003/03/15 17:21:58  bearcej
Fixed abstract tag.
Modified Files:
 Tag: ALPHA-0_7
    server-architecture.xml

Revision 1.1.2.2  2003/03/10 23:43:33  akarasulu
Moved links so that image references point to /image/design.  Note that
references do not have a [.] in front since the maven driven transforms
automatically append [.] to references.

Revision 1.1.2.1  2003/03/10 23:24:22  akarasulu
Moved design documentation from docs/design to src/docbook/design.

Revision 1.1.2.9  2003/03/02 00:37:32  akarasulu
Adjusting spacing.

Revision 1.1.2.8  2003/03/02 00:32:39  akarasulu
Completed listener documentation but needs some work and added the article
info tag to both these document.  Also flaged these docs as whitepapers.

                    </para>
                </revdescription>
            </revision>
        </revhistory>
    </articleinfo>

    <abstract>
    <para>
        The server consists of a set of loosely coupled modules.  All server
        modules are not created equally.  Some modules are stages that take
        part in the Staged Event Driven Architecture (SEDA) aspect of the 
        LDAPd server.  Some modules are startable, having a single driver thread.
        The simplest modules have no driver at all relying on the threads 
        of caller modules to drive their workload.  This document describes the
        modular structure of the server without delving deep into each specific 
        module, but rather defining what a module is, and the various types of 
        modules within the server.  Other documents are dedicated to the 
        implementation of each specific module.
    </para>
    </abstract>
    
    <section>
        <title>What is a Module?</title>
        
        <para>
            LDAPd is composed of modules, but what exactly is a module?  The
            definition is partly defined by the LDAPd project and partly defined
            by the Avalon Framework.  Avalon defines lifecycle methods for 
            components that fit into a framework.  Components define interfaces
            used to manage lifecycle operations.  These lifecycle aspects are 
            then automatically managed by a component conatiner using the 
            Inversion of Control Pattern.  Inversion of Control enables the
            construction of reusable loosely coupled components.  Avalon 
            Framework specifies the various lifecycle methods using interfaces
            that components may have.  The framework is just that, an API mostly
            composed of interfaces.  The designers of Avalon have thought of 
            all the possible generalized lifecycle methods, components may have
            and have forged a set of interfaces for component designers to use.
        </para>
        
        <para>
            The concept of an LDAPd module is defined in terms of Avalon 
            Framework interfaces.  In terms of lifecycle behavoirs, an LDAPd 
            module is a log enabled, configurable, initializable, startable, 
            and coincidentally, stopable, thread safe component with potential 
            dependencies on other components within the server.  The Avalon 
            Framework interfaces and their methods define these lifecycle 
            behavoirs.  We have programatically defined an LDAPd module as an 
            interface that extends many Avalon Framework interfaces.  Not 
            surprisingly, the name of the interface is Module and it is located
            in the org.apache.eve package.  All LDAPd modules must implement this 
            interface.  The Module interface simply states the lifecycle methods
            a module must implement.  The set of Avalon Framework interface's 
            extended by the Module interface are listed below:
        </para>

        <itemizedlist>
            <listitem><para>Startable</para></listitem>
            <listitem><para>ThreadSafe</para></listitem>
            <listitem><para>LogEnabled</para></listitem>
            <listitem><para>Serviceable</para></listitem>
            <listitem><para>Configurable</para></listitem>
            <listitem><para>Contextualizable</para></listitem>
            <listitem><para>Initializable</para></listitem>
        </itemizedlist>
        
        <para>
            Besides mandating the lifecycle functions, the Module interface 
            also defines extra methods used to query information regarding the 
            role, name and implementation of a Module.  More than one module 
            implementation can exist for a module service type, and the specific
            implementation chosen can be delayed until runtime.  Besides the
            Module interface, a base AbstractModule class is defined as an 
            adapter which correctly handles most of the lifecycle methods of a
            module.  Subclasses of AbstractModule are expected to implement 
            some criticle and highly specific interface methods to be concrete.
        </para>
    </section>

    <section>
        <title>Core Service Interfaces</title>
        
        <para>
            Building a module for the sake of implementing the required 
            lifecycle interfaces does not make sense.  A module needs to do 
            something by providing a service.  The Avalon Framework defines the 
            concept of a service interface for components.  Publicly exposed
            service interfaces provide methods that callers invoke to interact 
            with the service.  The service interface in this way defines the 
            role of the module within the server.  The service interfaces are 
            completely decoupled and independant of the lifecycle methods.
        </para>
        
        <para>
            LDAPd defines a set of core service interfaces which must be 
            implemented as server modules.  These are the set of manditory 
            services required to make the server work.  These services are
            listed below:
        </para>

        <table frame='all'><title>Mandarory LDAPd Services</title>
            <tgroup cols='3' align='left' colsep='1' rowsep='1'>
                <colspec colname='Interface'/>
                <colspec colname='Package'/>
                <colspec colname='Description'/>
                <thead>
                    <row>
                        <entry>Service Interface</entry>
                        <entry>Java Package</entry>
                        <entry>Service Description</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>UnifiedBackend</entry>
                        <entry>org.apache.eve.backend</entry>
                        <entry>The junction where all backends connect.</entry>
                    </row>
                    <row>
                        <entry>ClientManager</entry>
                        <entry>org.apache.eve.client</entry>
                        <entry>Maintains and tracks client sessions.</entry>
                    </row>
                    <row>
                        <entry>Decoder</entry>
                        <entry>org.apache.eve.decoder</entry>
                        <entry>Demarshals ASN.1 BER LDAPv3 messages</entry>
                    </row>
                    <row>
                        <entry>Encoder</entry>
                        <entry>org.apache.eve.encoder</entry>
                        <entry>Marshals ASN.1 BER LDAPv3 messages</entry>
                    </row>
                    <row>
                        <entry>EventManager</entry>
                        <entry>org.apache.eve.event.protocol</entry>
                        <entry>
                            Central point for firing and recieving protocol 
                            events - not related to stage events.
                        </entry>
                    </row>
                    <row>
                        <entry>InputManager</entry>
                        <entry>org.apache.eve.input</entry>
                        <entry>
                            Detects input on client channels to invoke the 
                            decoder.
                        </entry>
                    </row>
                    <row>
                        <entry>Encoder</entry>
                        <entry>org.apache.eve.encoder</entry>
                        <entry>Marshals ASN.1 BER LDAPv3 messages</entry>
                    </row>
                    <row>
                        <entry>JndiProvider</entry>
                        <entry>org.apache.eve.jndi</entry>
                        <entry>
                            Factory for internal serverside JNDI LdapContexts
                        </entry>
                    </row>
                    <row>
                        <entry>ServerListener</entry>
                        <entry>org.apache.eve.listener</entry>
                        <entry>
                            Detects initial connections between the client and 
                            the server.
                        </entry>
                    </row>
                    <row>
                        <entry>OutputManager</entry>
                        <entry>org.apache.eve.output</entry>
                        <entry>
                            Handles response PDU buffer streaming to the client.
                        </entry>
                    </row>
                    <row>
                        <entry>ProtocolEngine</entry>
                        <entry>org.apache.eve.protocol</entry>
                        <entry>
                            The heart of the server which processes protocol
                            requests to generate the protocol responses if 
                            required.
                        </entry>
                    </row>
                    <row>
                        <entry>SchemaManager</entry>
                        <entry>org.apache.eve.schema</entry>
                        <entry>
                            Maintains and stores schema related information
                            as specified in the config.xml and the various 
                            schema files associated with subschema authoritative
                            areas.
                        </entry>
                    </row>
                    <row>
                        <entry>AuthenticationManager</entry>
                        <entry>org.apache.eve.security.auth</entry>
                        <entry>
                            Manages simple authentication on LDAP bind 
                            operations both for admin and non-admin users.
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
    </section>
    
    <section>
        <title>Staged, Executable and Simple Modules</title>
        
        <para>
            As we mentioned before, not all modules are created equal.  Some
            modules participate in the SEDA aspect of the server.  These modules
            are stages and must in addition to the Module interface implement 
            the Stage interface or extend a base class in the org.apache.eve.seda 
            package.
        </para>
        
        <para>
            Without replicating Matt Welsh's paper on SEDA we'll consisely 
            define a stage as an event queue, a driver thread and a worker
            thread pool.  Stages recieve events which are popped off their 
            event queues and handed off to a worker thread for processing.  
            Events this way are processed in parallel and asynchronously.  In
            SEDA architectures, stages compose event processing pipelines that
            often out perform their strictly threaded or strictly event driven
            counterparts.
        </para>
        
        <para>
            Stages in LDAPd are modeled exactly as defined above.  They have an 
            event queue, a driver thread and a worker thread pool.  Within the
            LDAPd server the following core service interfaces are presently 
            implemented as stages composing the request processing pipeline:
        </para>
        
        <itemizedlist>
            <listitem><para>ClientManager</para></listitem>
            <listitem><para>OutputManager</para></listitem>
            <listitem><para>Encoder</para></listitem>
            <listitem><para>Decoder</para></listitem>
            <listitem><para>ProtocolEngine</para></listitem>
        </itemizedlist>

        <para>
            These service interfaces may not remain stages for long.  Presently
            the new IO (java.nio) functionality for nonblocking IO has not been 
            implemented.  Once implemented stages may split or fuse together. 
            Some modules may remain but may no longer become stages.  This is 
            dependent on how the architecture progresses.  What is certain is 
            that stages will be present as the components of the mature server.
        </para>
        
        <para>
            Simple modules, that are not stages also exist.  The following 
            service interfaces are implemented as simple modules without the use
            of any threads other than the thread of the caller to do work:
        </para>
        
        <itemizedlist>
            <listitem><para>AtomicBackend</para></listitem>
            <listitem><para>UnifiedBackend</para></listitem>
            <listitem><para>EventManager</para></listitem>
            <listitem><para>JndiProvider</para></listitem>
            <listitem><para>SchemaManager</para></listitem>
            <listitem><para>AuthenticationManager</para></listitem>
        </itemizedlist>

        <para>
            Some service interfaces are not implemented as stages, or as simple
            modules.  These implementations use one or more threads to perform
            some work outside of the thread of any caller.  There are two such
            service interfaces.  First the InputManager, which detects IO on 
            client connections uses a pool of threads to listen for client 
            input stream activity.  This is a temporary work around until the
            module is implemented using selectable channels within the new IO
            packages of the JDK 1.4+ platforms.  Once channels and channel 
            selection is used to implement nonblocking IO, one single thread 
            can be used by this module to detect IO on any number of clients
            concurrently.  This is where and when the true power of SEDA will
            reviel itself, until then we use this classic implementation.  
        </para>
        <para>
            The other service interface which is implemented neither as a stage 
            nor a simple module, is the ServerListener module.  Currently the 
            server listener uses a single thread to listen to a single port for 
            incomming connections.  Presently it cannot listen to more than one
            port.  It can be extended to listen to more ports by either using
            non-blocking selectors on multiple server socket's bound to more 
            than one port, or it can use one pooled thread per server socket.
            Nevertheless both these service interface implementations will 
            change, without changing the interface itself, to reduce the number
            of threads used while increasing concurrency.  These modules may also
            fuse together using a single channel selector for both client accept 
            and input IO events.
        </para>
    </section>
    
    <section>
        <title>Service Interfaces and Modules</title>
        
        <para>
            Every core service interface defined is implemented as a server 
            module whether it be as a simple module, a staged module or other.  
            Each interface has a single implementation instance at runtime with 
            the exception of AtomicBackends.  Several AtomicBackend 
            implementations may exist for various entry backing stores.  
            Currently, there are three different AtomicBackend types: the 
            modjdbm, modjdbc and the BerkeleyDB backend.  Multiple backend
            instances of the same type or of different types can coexist in the
            same server process instance.  Each AtomicBackend instance is only 
            required to have a unique suffix DN to differentiate itself from 
            other backends.  One or more AtomicBackend instances hang off of the 
            UnifiedBackend service which is implemented by the NexusModule.  
            Below we list the various service interfaces and their corresponding 
            Module implementations excluding the AtomicBackend implementations:
        </para>
        
        <itemizedlist>
            <listitem>
                <para>NexusModule implements UnifiedBackend</para>
            </listitem>
            <listitem>
                <para>ClientModule implements ClientManager</para>
            </listitem>
            <listitem>
                <para>DecoderModule implements Decoder</para>
            </listitem>
            <listitem>
                <para>EncoderModule implements Encoder</para>
            </listitem>
            <listitem>
                <para>EventModule implements EventManager</para>
            </listitem>
            <listitem>
                <para>InputModule implements InputManager</para>
            </listitem>
            <listitem>
                <para>OutputModule implements OutputManager</para>
            </listitem>
            <listitem>
                <para>JndiProviderModule implements JndiProvider</para>
            </listitem>
            <listitem>
                <para>ListenerModule implements ServerListener</para>
            </listitem>
            <listitem>
                <para>ProtocolModule implements ProtocolEngine</para>
            </listitem>
            <listitem>
                <para>SchemaModule implements SchemaManager</para>
            </listitem>
            <listitem>
                <para>AuthenticationModule implements AuthenticationManager
                </para>
            </listitem>
        </itemizedlist>
    </section>
    
    <section>
        <title>Request Processing</title>
        
        <para>
            Without using a highly detailed sequence diagram we shall represent 
            at a very high level the flow of SEDA based events within the system 
            while processing requests that have a single response. 
            <ulink url="images/ReqRespStageFlow.gif">Figure I</ulink> 
            is a very high
            level stage to stage processing sequence for requests that have a
            single response.  LDAPv3 abandon and unbind requests have no 
            responses and LDAPv3 search requests may have one or more responses
            so these requests are not entirely represented in this diagram.  
            Keep in mind that this sequence diagram trivializes the staged 
            processing by only showing the stage modules and the events they
            generate within the pipline.  Other modules that are used indirectly
            while servicing these requests are not shown.  More detail 
            concerning module interactions downstream of the ProtocolEngine are
            provided in the protocol engine's implementation documentation where
            each request processor implementation is outlined.
        </para>

        <para>
            Briefly, Abandon and Unbind requests never produce a response and 
            Search requests have the potential of generating more than one 
            response.  Reponseless requests simply stop processing after the 
            respective request processor completes processing within the 
            ProtocolModule. The Search request is more complex requiring 
            synchronized delivery of messages in a specific order.  Special 
            methods are used to bypass staged event handling both in the 
            EncoderModule and in the OutputModule when search requests with more 
            than one response are processed.  Serial delivery of entry responses 
            in a search requires special synchronous pathways through the 
            Encoder and Output modules.  The last search done reponse, however 
            goes through the standard staged event handling mechanism.  Again,
            Search, Abandon and Unbind LDAPv3 request processing is discussed 
            in more detail within the low level implementation document for the
            ProtocolModule.
        </para>

        <section>
            <title>Input Detection Stage</title>
            <para>
                In the solid state, when all modules have started up, and after 
                a client has established a connection, an input handler assigned 
                to every client connection, blocks waiting for IO activity on 
                the input stream of the client socket.  Once incomming data is 
                detected an InputEvent is generated and enqueued on the event 
                queue of the DecoderModule.
            </para>
        </section>
        <section>
            <title>
                Protocol Data Unit (PDU) Decoding Stage (PDU Demarshaling)
            </title>
            <para>
                Once the InputEvent is dequeued and processed a decoding occurs 
                while reading the input stream to build a LDAP request message 
                envelope.  This stage demarshals the incoming PDU on the client 
                input stream using Binary Encoding Rules (BER).  Once the 
                demarshaling is complete a RequestEvent is assembled with the 
                demarshalled request PDU and enqueued onto the ProtocolModule 
                stage for handling and response generation.
            </para>
        </section>
        <section>
            <title>Request Protocol Handling Stage</title>
            <para>
                Once the RequestEvent is dequeued by the ProtocolModule's driver
                thread a protocol request processor is created to process the 
                request PDU.  A stage worker pool thread is used to drive the 
                processing.  Depending on the nature of the protocol request 
                various modules downstream from protocol engine may be directly 
                or indirectly called upon to complete the request.  Most of the 
                time the NexusModule is called which routes requests to the 
                appropriate target backend based on the backend suffix.  Some 
                protocol requests are special in that they do not return a 
                response or potentially return more than one response.  Such
                protocol request types are refered to specifically in the 
                protocol engine documentation.  For the majority of request 
                types the processors generate a response message envelope to 
                be delivered back to the client on the socket output stream.
                The protocol engine can differentiate between those request 
                types that generate a response and those that do not.  After, 
                and if, a response is generated, it is packaged within a newly
                created ResponseEvent.  This event is enqueued onto the Encoder
                stage's event queue.
            </para>
        </section>
        <section>
            <title>Response Encoding Stage (PDU Marshaling)</title>
            <para>
                Once the ResponseEvent is popped off of the event queue by the
                driver thread of the EncoderModule, the packaged response 
                message envelope (LDAPMessage instance) is accessed.  The object
                is marshalled into a BER encoded buffer stream.  A input stream
                to this buffer is created and packaged within a OutputEvent 
                which is then enqueued on the event queue of the OutputModule
                stage.
            </para>
        </section>
        <section>
            <title>Output Handling Stage</title>
            <para>
                Once the OutputEvent is popped off of the event queue by the
                driver thread of the OutputModule, the encoded response PDU can 
                be pumped from the buffer into the OutputStream of the client.
                Synchronized access to the OutputStream of the client is 
                acquired from the ClientModule using the ClientKey packaged in
                the OutputEvent.  A worker thread form the stage's worker thread
                pool is assigned to pump the bytes stored in the BER encoded 
                buffer accessed via an InputStream into the OutputStream of 
                the client.  This is not an optimal implementation but it works 
                for now allowing for full system integration testing.  
                Optimization efforts specifically targeting the JDK1.4 platform
                (using non-blocking selectors and fast direct memory buffers) 
                will be underway within the first beta releases.
            </para>
        </section>
    </section>

    <section>
        <title>Module Interdependence</title>
        
        <para>
            Modules within the server indirectly depend on one another since 
            they must call each other's service interface methods to process 
            client requests.  Modules depend on service interfaces (ROLE's), not 
            on module's implementing those interfaces.  This keeps the modules
            decoupled and is a motif brought about through the use of Avalon.
            Cyclic dependencies can however create a chicken and egg problem for 
            the server kernel (container) used to fire up the server's modules.  
        </para>
        
        <para>
            The LDAPd server avoids these cyclic dependencies by designating the 
            ClientModule as a master module and those that depend on it in a 
            cycle as ClientManagerSlaves.  Many modules need to access client
            session information managed by the ClientModule.  The ClientModule
            however passes on requests to the InputModule, which later passes
            on requests to the ProtocolModule and so on until the OutputModule.  
            If any of these modules downstream of the ClientModule need to 
            access the client's session or request its termination they need to
            make calls to the ClientModule's service interface.  This imposes a
            cyclic dependency when standard container mechanisms are used 
            to get handles on the services an interface modules depend upon.  In 
            Avalon Framework, the Serviceable interface (required by all LDAPd
            Modules) has the service method, which is the standard mechanism for
            getting a handle on another service.  When containers detect cycles
            by monitoring the service lookups made by a Serviceable component,
            they complain and reject initialization.  Our little workaround for
            these unavoidable cyclic dependencies is to, in some respects, 
            violate, yet formalize a registration mechanism outside of the 
            Serviceable paradigm, thereby bypassing cycle detection in some 
            pathological cases.
        </para>
        
        <para>
            Upon recommendations from the Avalon team we constructed a special
            ClientManagerSlave interface.  This interface has a single method
            which is used to register the ClientModule (a.k.a. the 
            ClientManager).  By passing the handle to the ClientManager using 
            ClientModule initiated registration, modules dependent on the 
            ClientManager service need not raise cyclic dependency errors.  
            Regardless cyclic references exists but because the Serviceable 
            interface is not used to grab the handle containers don't choke.  
            This is why the InputManager, OutputManager and the ProtocolEngine 
            interfaces extend the ClientManagerSlave interface.  On 
            initialization the ClientManager registers itself with the 
            ClientManagerSlaves so they need not lookup the ClientManager within
            the service lifecycle method.
        </para>
        
        <para>
            <ulink url="images/ModuleDependencies.gif">Figure II</ulink>
            is a component
            diagram which depicts the service interfaces and the modules that
            implement them.  The components are modules that have a solid 
            supporting link to a circular service interface node.  Note that
            the modules are service interface implementations and they have 
            directed dotted line dependencies on the service interfaces 
            supported by other modules.  Modules never directly depend on other
            modules, nor should they ever!  
        </para>
    </section>
    
    <section>
        <title>Conclusion</title>
        <para>
            Our goals in this article were to introduce the fundimental modular
            architecture of the server.  We want readers to be able to 
            comprehend how server modules are defined according to the Avalon
            Framework APIs.  Readers should therefore understand what a module 
            is as a Avalon Component and which service interface is supported
            by each critical server module.  We would also like readers to step 
            away with a rough understanding of the SEDA stages within the server
            and to be able to differentiate between simple modules, stages and 
            those that fall under neither category.  Ultimately users should 
            possess an understanding of module dependencies and their 
            interactions within the processing pipeline for LDAP requests with 
            the subsequent transmission of a response.
        </para>
    </section>
    
</article>
